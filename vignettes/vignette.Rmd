---
title: "Assessing food web stability with the fwstability R-package."
author: "D.S.W. de Jonge"
date: "`r date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette explains how you can use the fwstability package to assess food web stability. There are basically six sections:  

1) Quick start,  
2) how to prepare your food web model for stability analysis,  
3) how to derive the Jacobian matrix,  
4) how to conduct stability analysis,   
5) how to assess your food web for characteristics related to stability, and   
6) examples with food webs from literature.  

These sections contain details about all the features of the package and the scientific background. Reading this is highly recommended so that you can interpret your results correctly. This quick start section will give you a general idea about the usage of the package.

# Quick start
Install.

First, we load the package.
```{r setup}
library(fwstability)
```

# 1. Preparing a food web model for stability analysis
## 1.1. A linear inverse model
In a linear inverse model (LIM) all processes in a food web are captured by a set of linear equations. These linear equations can be either equalities (the outcome of an equation should equal another value) or inequalities (the outcome of an equation should be equal or greater than another value). The equations can parameterized with known data, but often not all processes are studied well enough to quantify. The unknowns in the equations can then be found with linear programming, thereby fully quantifying your model. A simple example of a linear optimization problem can be found on \link{Wikipedia}[https://en.wikipedia.org/wiki/Linear_programming#Example]. More information on using LIM for food web quantification can be found in:  
van Oevelen, D., van den Meersche, K., Meysman, F.J.R., Soetaert, K., Middelburg, J.J., Vézina, A.F., 2010. Quantifying food web flows using linear inverse models. Ecosystems 13, 32–45. https://doi.org/10.1007/s10021-009-9297-6.

A linear inverse food web model (LIM) can be prepared with the R-package LIM (https://cran.r-project.org/web/packages/LIM/index.html). The example food web models used in this section are the same food web model as in the LIM vignette with small alterations, so please refer to this document to understand the concept and set-up of a LIM. A LIM model produced by the LIM package can be used directly by the fwstability package if it is formatted in a certain why. If your model is not formatted according to the requirements of the package, you will need to extract certain data from the model yourself before using the package. Both are explained below.

### 1.1A. Formatting of LIM model for direct usage in the fwstability package
In order to obtain a Jacobian matrix, certain physiological processes must be calculated from your LIM. The fwstability can automatically extract this data if you labelled them with a unique tag. In the model you specify:  

- which compartments are dead compartments (e.g. detritus and carrion, default tag is "dead")  
- which flows specifically represent defecation (default tag is "def")  
- which flows specifically represent mortality (default tag is "mort")  
- which variables represent total assimilation (default tag is "ass", beware to not tag assimilation *efficiency*)  
- which variables represent total growth (secondary production, default tag is "growth", beware to not tag growth *efficiency*)  

You can use the default tags, but it is also possible to use your own tags. In the latter case you will need to provide the package with the name of your chosen tags in order to extract the correct information. The package will warn you if it cannot find the tag in your model. 

Rules and tips for using tags:   

- The official componentname is the name given in the 'stocks' section. Sometimes, stock values are already given in the 'parameter' section and then assigned to the defined stocks in the 'stocks' section. Be aware not to tag the compartments in the 'parameter' section as these are not the official stock names used throughout the rest of the model analysis.  
- Flows that represent defecation and mortality **must be named in the 'flows' section and include the defecation or mortality tag**. If defecation and mortality are combined in the same flow, they should still be declared seperately (so you get the same flow twice, but with a different name).  
- The variables representing total defecation, mortality, assimilation, and growth should be **named by combining the component name and tag only**. The code subtracts the tag from the name of the variable and uses it to place the data with the right compartment. So, a variable containing total rabbit mortality should be named "rabbitMort". If you would name it "thisisRabbitMort" it is not recognized due to the superfluous text. It is possible to specify multiple mortality flows, e.g. if the carcass of the rabbit consists of both high-energy and low-enegy material which you want to seperate into two separate carcass compartments. In this case it is necessary to define rabbitMort as the sum of these flows in the variable section of the model.  
- **Tags are not case sensitive**. So, RABBITmort and RaBbItMoRt are both valid.  
- **The tag may occur anywhere in the string** (so, it does not have to be added specifically at the beginning or ending of the name of the compartment/flow/variable). Ensure that the rest of names do not accidentally contain a tag! For example, if you include the Indian wild ass (*Equus hemionus khur*) in your foodweb, a variable representing its respiration called respirationAss will be interpreted as the assimilation variable of an unknown compartment 'respiration' because it contains the default assimilation tag "ass".    
- Dead compartments, defecation, and mortality can be omitted from your model if you don't want to include them (for example make them all export to an external compartment). However, including assimilation and growth is required for all non-dead compartments. If you have no growth or assimilation data (for example for bacteria) you can assume the full ingestion is used for assimilation and/or growth and define your variable accordingly.  



General tips for setting up a LIM:  

- It is recommended to be consistent in your naming of flows and variables so later you can easily extract data. For naming flows for example: sourceProcessSink.  
- In order to prevent certain processes to be quantified as zero, include minimum constraints. This is especially important if you later want to normalize the Jacobian matrix, because this process does not allow zeroes on the diagonal. For example, if you don't set a minimum constraint for non-predatory mortality, the parsimonious solution might set this flow to zero. This is not realistic and it the occurence of these zeroes may hamper your future calculations.

Specifying your compartments in a LIM input file can look like this:  
*****  
\#\# EXTERNALS  
CO2  
EXPORT  
\#\# END EXTERNALS  

\#\# COMPARTMENTS  
Plant = 700 {g C m-2}  
Animal = 50 {g C m-2}  
deadDetritus = 1000 {g C m-2} ! contains the default "dead" tag  
xxxDetritus  = 1000 {g C m-2} ! chosen tag "xxx" is equally valid if you specify this for the fwstability package.  
\#\# END COMPARTMENTS  
*****  

Specifying flows can look like this:  
*****  
\#\# FLOWS  
NetPrimProd     : CO2 -> Plant  
animalGrazPlant : Plant -> Animal  
animalGrazDetritus: deadDetritus -> Animal  
animalResp      : Animal -> CO2  
animalMort      : Animal -> EXPORT  
animalYYY       : Animal -> EXPORT ! equally valid mortality tag, if specified for the package later.  
plantMort       : Plant -> deadDetritus   
animalDef       : Animal -> deadDetritus  
detritusMineralization: deadDetritus -> CO2  
\#\# END FLOWS  
*****  
Make sure you use the name as specified in "COMPARTMENT", so including the tag for dead compartments. The name of defecation and mortality flows should only contain the name of the compartment and the tag. If it contains more words, like "thisAnimalMort" the package ignores this flow. If, for some reason, you want to include multiple parallel defecation or mortality flows, you need to define a variable (in the VARIABLE section) that includes the sum of all defecation and mortality flows. Like this:  
*****   
\#\# FLOWS  
animalDefOne       : Animal -> deadDetritusOne    
animalDefTwo       : Animal -> deadDetritusTwo  
\#\# END FLOWS  

\#\# VARIABLES  
animalIngestion = animalGrazPlant + animalGrazDetritus  
animalIngestion = flowto(Animal) ! Usefull feature of LIM package
animalDef       = animalDefOne + animalDefTwo ! Sum all defecation flows  
animalAss       = animalIngestion - animalDef ! Default assimilation tag "ass"  
animalGrowth    = animalAss * animalGrowthEfficiency ! Default growht tag "growth"  
\#\# END VARIABLES  
*****  

When your LIM input file is done, you can read it into R, and optionally solve it with the LIM package. 
```{r}
# Use the LIM package for importing your model
require(LIM)
lim <- Read(system.file("extdata", "foodweb.lim", package = "fwstability"))
# This example is only one of many ways to solve a LIM.
lim_solved <- Ldei(Setup(lim))
```

The model should be included in a list that can later be parsed into the getJacobian function. The getJacobian matrix will need a list with at least the elements "type" and "model". The element "type" must be set to "LIM", and the element "model" is the read-in LIM (beware, not yet set up!). If there is no solution specified, the parsimonious solution is used (minimizing the sum of squares).
```{r eval = FALSE}
mymodel <- list(
  type = "LIM",
  model = lim
)
# Ready to use in the fwstability package!
```

If you have solved the model, you can include it in your list under the element "web" so that it can be used by the package. This element must be a named vector with flow values and their names.
```{r eval = FALSE}
mymodel <- list(
  type = "LIM",
  model = lim,
  web = lim_solved$X
)
```

If you use your own tags in the model, for example "RIP" in stead of "MORT", you  need to specify this in the list under the elements "aTag", "gTag", "mTag", "deadTag", and/or "defTag". If one or more of these elements are omitted, the default tags are used.
```{r eval = FALSE}
# Example when I want to use my own tags for growth, mortality and defecation.
mymodel <- list(
  type = "LIM",
  model = lim,
  gTag = "production",
  mTag = "RIP",
  defTag = "poop"
)
```

If setting up your model takes a long time (quite rare), you can include your set-up model in the element "setup" so that it is not setup within the function.
```{r eval = FALSE}
setupLIM <- Setup(lim)
mymodel <- list(
  type = "LIM",
  model = lim,
  setup = setupLIM
)
```

The getJacobian function by default creates an all-zero diagonal. If you want another diagonal you can specify this in your list under the element "diagonal". The options are either a single value (will set the whole diagonal to this value), a numeric vector, or the word "model" which will calculate the upperbound values of the diagonal from the model.
```{r eval = FALSE}
mymodel <- list(
  type = "LIM",
  model = lim,
  diagonal = "model"
)
```


### 1.1B. Energy flux model
If you don't have a LIM or your LIM is formatted in such a way that it cannot be automatically used by the getJacobian function, you need to extract the necessary data first. In order to obtain a Jacobian matrix you need:  

- a flowmatrix containing the total flow of material/energy between compartments.   
- a named vector with biomasses for all compartments (including the dead ones).  
- a named vector with assimilation efficiencies for all non-dead compartments. An organism assimilates (A) the part of all ingested food (I) that is not defecated (D): $A = I-D$. So, assimilation efficiency (AE) is the assimilated amount of food (A) divided by the total of ingested food (I): $AE = A/I $.  
- a named vector with growth efficiencies for all non-dead compartments. The part of assimilated food (A) that is not respired (R) is used for growth or secondary production (G): $G = A-R$. Therefore, the growth efficiency (GE) is the total growth (G) divided by the assimilated part of food (A): $GE = G/A$.  

Optionally, you can specify:  

- a list containg three elements with the names of dead compartments (element "names"), if those compartments receive feaces (string "Def") or not (string "noDef") (element def), and a matrix with the fraction of each flow that constitutes defecation (element "frac"). The element "def" and "frac" are optional. If "def" is omitted, it is assumed no defecation occurs in the food web. The element "frac" is only necessary if you have multiple parallel flows between two compartments, of which only one or a couple constitute defecation.  
- a character vector containing the names of external compartments (these are removed from the flowmatrix before the calculations).  
- a numeric vector with mortality rates (in the same unit as the flowmatrix). This information is obligatory if you want to calculate diagonal values for the Jacobian matrix from the flux values. Perhaps this is already included in your model as a flow from the organism into a detritus or carrion compartment. Beware that these mortality rates must represent non-predatory mortality! Mortality rates can be searched for in literature or calculated as the inverse of the natural lifespan (per unit time) and multiplied by the biomass of the compartment to obtain the same unit as in the flowmatrix.  


This information should be combined in a list that also contains the element "type" which is set to "EF" (short for energy flux) so that it can be parsed into the getJacobian function. It can also be used directly into the getJacbianEnergyFlux function. For a working example please see the examples from literatures De Ruiter 1995.  

```{r}
# An example food web model (not necessarily ecologically correct...)
# Detritus takes up CO2.
# Plants and animals take up detritus.
# Plants are eaten by animals.
# Animals and plants both deposit material into detritus compartment.
# Animals respire into the external CO2 compartment.
compartments <- c("DETRITUS", "PLANT", "ANIMAL", "CO2")
# A named flow matrix
FM <- matrix(c(0, 3, 8, 1, 7, 0, 0, 0, 4, 4, 0, 0, 0, 0, 1, 0), nrow = 4, ncol = 4)
rownames(FM) <- compartments
colnames(FM) <- compartments
# Named numeric vectors with biomasses, assimilation efficiencies,
# and growth efficiencies
BM <- c(30, 20, 10) ; names(BM) <- compartments[1:3]
AE <- c(NA, 0.2, 0.3) ; names(AE) <- compartments[1:3]
GE <- c(NA, 0.2, 0.3) ; names(GE) <- compartments[1:3]
# There is one dead compartment into which defecation occurs.
# All flow from the animal to detritus constitutes defecation (and
# not for example also mortality) so the element "frac" is omitted.
dead <- list(names = "DETRITUS", def = "Def")
# There is one external compartment
externals <- "CO2"

# Option 1
model <- list(
  type = "EF", 
  FM = FM, 
  BM = BM, AE = AE, GE = GE,
  dead = dead, externals = externals
)
getJacobian(model)

# Option 2
getJacobianEnergyFlux(
  FM = FM, 
  BM = BM, AE = AE, GE = GE,
  dead = dead, externals = externals)
```

If you have a LIM with the wrong data format, the functions getFlowMatrix and getVariables  may still be of use to easily calculate the needed data. The function getFlowMatrix is similar to the function Flowmatrix from the LIM package, but enhanced so that it also works if parallel flows exist between the same two compartments. The function getVariables returns a named list with the values of all defined variables calculated from the food web flows. So, for example, if you have defined variables related to assimilation but for some reason didn't use the tag system, you can easily extract the variables values and find your assimilation efficiency.

```{r}
# Use the LIM package for importing your model
require(LIM)
lim <- Read(system.file("extdata", "foodweb.lim", package = "fwstability"))

FM <- getFlowMatrix(lim)
print(FM)

vars <- getVariables(lim)
print(vars)
```


## 1.2. A dynamic model
A dynamic food web model is a set of differential equations that describe the change in biomass of each food web compartment based on the biomass of other compartments and potentially other factors. It is common to use a set of (generalized) Lotka-Volterra equations for your food web model. The form of a generalized Lotka-Volterra equation is:
$$\frac{dx_i}{dt} = x_i (r_i + \sum_{j=1}^n c_{ij}x_j) $$
where $r_i$ is the natural per capita growth rate and $c_ij$ is the coefficient of the interaction i.e. the effect of population $j$ on population $i$. 

Lets create a dynamic model based on the same food web structure and data as the linear inverse model described above. Plants have a natural growth rate as they take up CO2 for primary production. Furthermore, plants are negatively impacted by animals as they are preyed upon. Plants have a negative effect on their own population growth, and are not influenced by detritus. Growth of animals is dependen on the feeding on plants. Animals, like plants, have a negative effect on their own population growth. Detritus have natural decline by decomposition, but are positively affected by animal defecation and plant waste.

The deSolve package is great for solving a system of orginary differential equations. You can write your model in R, plug in parameters, and simulate the change over time in your ecosystem.
```{r Lotka-Volterra}
library(deSolve)
library(ggplot2)

fwnames <- c("PLANT", "ANIMAL", "DETRITUS")

# Define the set of differential equations
LotkaVolterra <- function (Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    dP = PLANT * (r1 - c11 * PLANT - c12 * ANIMAL)
    dA = ANIMAL * (-r2 + c21 * PLANT - c22 * ANIMAL - c23 * DET)
    dD = DET * (-r3 + c31 * PLANT + c32 * ANIMAL - c33 * DET)
    return(list(c(dP, dA, dD)))
  })
}

# Parameters to initialize model
#Pars <- c(alpha = 2, beta = 0.5, gamma = 0.2, delta = 0.6)
Pars <- c(
  r1 = 10, r2 = 1, r3 = 1,
  c11 = 0.05, c12 = 0.5,
  c21 = 7, c22 = 0.5, c23 = 0.5,
  c31 = 0.75, c32 = 3, c33 = 2
)
# Initial biomass of compartments
State <- c(PLANT = 10, ANIMAL = 5, DET = 10)
# Time to run the simulation
Time <- seq(0, 50, by = 1)

# Run and plot simulation
simulation <- ode(func = LotkaVolterra, y = State, parms = Pars, times = Time)
plot <- ggplot(as.data.frame(simulation)) +
  geom_line(aes(x = time, y = PLANT), colour = "green") +
  geom_line(aes(x = time, y = ANIMAL), colour = "blue") +
  geom_line(aes(x = time, y = DET), colour = "brown")

```

Mathematically speaking, the Jacobian matrix contains elements $\alpha_{ij}$ which are the first-order partial derivatives of each differential function valued with initial state biomasses. The rootSolve package numerically estimates these values by perturbing the initial state values.

```{r}
library(rootSolve)
newState <- simulation[50,2:4]
JM <- jacobian.full(y=newState, func=LotkaVolterra, parms = Pars)
rownames(JM) <- fwnames ; colnames(JM) <- fwnames
print(JM)
```

This Jacobian matrix already contains diagonal values. The stability can be found from this complete Jacobian matrix.
```{r}
getStability(JM)
```


Jacobian matrix from a ODE model
This function produces a Jacobian matrix from a model defined as a set of
ordinary differential equations.
@inheritParams rootSolve::jacobian.full
@seealso The package rootSolve for full documentation on \code{\link[rootSolve]{jacobian.full}}.
getJacobianODE <- function(y, func, parms) {
  JM <- rootSolve::jacobian.full(y = y, func = func, parms = parms)
  rownames(JM) <- colnames(JM)
  return(JM)
}

# 2. Obtaining a Jacobian matrix
This food web model consists of three compartments of which the biomass is measured; Plants, Animals, and Detritus, and two external compartments with infinite biomass; CO2 and export. The unit of biomass is g C m-2 and the unit of flow flux is g C m-2 d-1. Plants take up CO2 and are consumed by Animals. Animals also consume Detritus. Both Plants and Animals deposit carbon into the Detritus compartment through natural mortality and defecation. Animals respire into the CO2 compartment and export carbon from the system, for example when they are predated upon by external animals. Detritus decomposes and thereby releases carbon into the CO2 pool. 

Some of these flows are constrained by measured values. Therefore, linear programming can be used to find the parsimonious solution of all the flows (see LIM vignette). The quantified flows are stored in FM. 

Based on the final flow values and the constraints defined in the model it is possible to calculate the assimilation and growth efficiencies of animals and plants. Assimilation efficiency is 1 - (defecation / ingestion) and assumed 1 for Plants. Growth efficiency is defined in model for Animals and assumed 1 for Plants. The vectors containing biomass, assimilation and growth efficiencies must be named for usage in the getJacobian function. If assimilation and growth efficiencies are not specified in the model, or cannot be calculated from the model, you can estimate a value or try to find a value from literature.

```{r eval = FALSE}
# Order Plant, Animal, Detritus. Just like the FM.
AE <- c(1, 1 - (FM[2,3] / sum(FM[,2])), NA)
GE <- c(1, 0.3, NA)
BM <- lim$Components$val
names(AE) <- rownames(FM)[1:3]
names(GE) <- rownames(FM)[1:3]
names(BM) <- rownames(FM)[1:3]
```

The food web data and calculated flows can be used to calculate a Jacobian matrix with the function getJacobian(). It is important to tell the function which compartments to regard as dead compartments (in this case detritus) and which compartments are external.
```{r getJacobian, eval = FALSE}
JM <- getJacobian(
  FM = FM,
  BM = BM,
  AE = AE,
  GE = GE,
  dead = c("DET"),
  externals = c("CO2", "EXP")
)

print(JM)
```

The interaction strengths have the unit per time. In our food web model the flows were g C m-2 d-1 and biomass g C m-2, so the interaction strengths have the unit d-1.

From the interaction strengths in the Jacobian matrix we observe that Animals have a negative effect on the growth of Plants, and Plants have a positive effect on Animals, which makes sense because Plants are eaten by Animals. Detritus for this same reason has a positive effect on Animals. Both Plants and Animals have a positive effect on detritus, despite the fact that Detritus is consumed by Animals. This is caused by the fact that Animals overall deposit more Detritus than they take up. This highlights the importance of including Detritus as a dead compartment in the function. If we would leave out this argument the Detritus compartment would be viewed as a living compartment which can actively consume other compartments. In that case the deposition of feces would be regarded as predation on the animals by detritus, which makes no sense.  

In the getJacobian function, the effect of a predator on its prey ($\alpha_{ij}$) is calculated as:

$$\alpha_{ij}=-\frac{F_{ij}}{x{j}}$$
and the effect of a prey on its predator($\alpha_{ji}$) is calculated as:

$$\alpha_{ji}=\frac{a_jp_jF_{ij}}{x{i}}$$
where $F_{ij}$ is the flux between resource population $i$ and consumer population $j$, $a_j$ is the assimilation efficiency of the consumer, $p_j$ is the production efficiency of the consumer, and $x_{i,j}$ is the biomass of the respective population (de Ruiter et al., 1995; Neutel et al., 2002).

The effect of a population $j$ on detritus ($\alpha_{dj}$) is calculated as:

$$\alpha_{dj}=\frac{1}{x_j}(F_{jd} - F_{dj} + \sum_{k=1}^n (1-a_k)F_{jk})$$
where $n$ is the total number of compartments in the food web (Neutel & Thorne, 2014).

The diagonal of a Jacobian matrix represents intraspecific interactions. The default diagonal of the function getJacobian() is to set all values to zero. Neutel & Thorne (2014) show that an all-zero diagonal (with exception of detritus flows) has the biological meaning of a tipping point where any loss of self-dampening effect or intraspecific competition will cause the system to collapse. Diagonal values can also be calculated from the energy-flux model. Diagonal values for fauna are found as their non-predatory mortality (Neutel & Thorne, 2014):
$$\alpha_{ii}=-\frac{\sum_{j=1}^n a_i p_i F_{ji}-\sum_{j=1}^n F_{ij}}{x_i}$$
and for detritus as:
$$\alpha_{dd}=-\frac{1}{x_d} \sum_{j=1}^n (a_j F_{dj})$$

The Jacobian matrix we calculated earlier had the default all-zero diagonal. You can also decide to calculate diagonal values from the flux values as described by the equations above. In order to do this, natural mortality rates (biomass per unit time) are needed. There are several ways to obtain these values:  

1) Sometimes your food web model will specifically include a natural mortality flow. You can simply extract this information from your model into a named vector and use it as input.  
2) You can multiple the biomass by the inverse of the lifespan. The inverse of the lifespan represents the fraction of biomass that will disappear due to natural mortality on a certain time scale. For example, the biomass of animals in the example food web model is 50 g C m-2 and the natural lifespan of these animals is assumed to be 30 days. Then the natural mortality rate is 50 * 1/30 = 1.67 g C m-2 d-1. This lifespan should NOT include mortality due to predation, and be a good representative for the whole compartment.  

To calculate diagonal values based on the model we include the argument "diagonal" and set the value to the string "model". In our model natural mortality flows are already specified, so we can extract this information and use it as input for the mortality rates argument "MR". The mortality rate for Detritus is set to NA.

```{r getJacobian_diagonal, eval = FALSE}
MR <- c(FM["PL","DET"], FM["AN", "EXP"], NA)
names(MR) <- rownames(FM)[1:3]

JM2 <- getJacobian(
  FM = FM,
  BM = BM,
  AE = AE,
  GE = GE,
  dead = c("DET"),
  externals = c("CO2", "EXP"),
  diagonal = "model",
  MR = MR
)

print(JM2)
```

Some notes:
- The inclusion of biomasses in the LIM is not required to be able to solve the model. However, it is required that all internal compartments have quantified biomasses to calculate the Jacobian matrix. If there are compartments that do not have biomasses in the LIM, they must either be quantified anyway or excluded from the getJacobian() function by including them as 'externals'.
- The diagonal values calculated from the model for non-dead compartments represent the UPPER bound (in absolute value). This means we assume maximum self-dampening effects of populations. Jacobian matrixes with model-based diagonals are therefore often stable. If you want to compare stability between two food web models that are initially both stable, you can redefine stability as the minimum fraction of natural mortality needed to stabilize the matrix (see below 2. Stability analysis).

# 3. Stability analysis
A Jacobian matrix is only stable if all real parts of the eigenvalues are negative. Therefore, the stability of a Jacobian matrix can be measured as the maximum real value of the eigenvalues. A negative value indicates a stable matrix, a positive value indicates an unstable matrix.
```{r eval = FALSE}
# Using the default 'eigenvalue' method.
# Jacobian matrix with all-zero diagonal
getStability(JM)
# Jacobian matrix with calculated values on the diagonal
getStability(JM2)
```

The first Jacobian matrix with an all-zero diagonal is an unstable matrix, whereas the second Jacobian matrix with a diagonal calculated from the model is indeed stable. This highlights the importance of thinking about how you want to quantify your diagonal. 
If you use different methods to quantify the diagonal the stability of different models are are not comparable.

There is a second stability measurement that is commonly used, that allows comparison of food web models that are initially stable. In this case the minimum fraction of self-dampening needed to stabilize the Jacobian matrix is used as measure. For example, two Jacobian matrices with a diagonal calculated from the model are stable i.e. the maximum real part of the eigenvalues is negative. The diagonal of both Jacobian matrices contain the upper bound values representing the maximum possible self-dampening effect possible. If you start reducing the self-dampening effect, at some point the Jacobian matrix will become unstable. If the first matrix becomes unstable with 75% of its original self-dampening and the second becomes unstable at 50% of its original self-dampening, we can conclude that the second matrix is more stable than the first one. The second matrix requires a lot less intra-specific feedback to dampen the destabilizing effects of interspecific interactions.

This concept is implemented in the getStability() function using the 'scalar' method. For this method the additional argument mortalities is required, and 'dead' is required only if there are indeed dead compartments.
```{r eval = FALSE}
getStability(JM2, method = "scalar", 
             mortalities = MR/BM, dead = "DET")
```

In this case, the diagonal value for detritus is calculated from the model (see 1. Preparing a food web model for stability analysis). If we then scale the natural mortality rates of non-dead compartments we see that the minimum fraction natural mortality needed to stabilize the matrix is 0.45. This means that at least 45% of the maximum self-dampening effect of populations is needed in order to buffer pertubations to the whole system.


# 4. Analysize food web for (de)stabilizing characteristics
show in vignette that doubling small interaction strength can have larger
effect on stability than doubling large interaction strengths, thus a
function + 10 would be more difficult to interpret in stead of relative change.
per link (not per link pair) also intraspecific interaction.

# 5. Examples from literature

## de Ruiter et al. (1995) Energetics, Patterns of Interaction Strenghts, and Stability in Real Ecosystems. Science, 269 (5228), 1257 - 1260

In the Science paper by de Ruiter et al. (1995) the stability of seven food webs is assessed. The soil food web of the Lovinkhoeve Experimental Farm is singled out and a energy-flux model is provided including biomasses (kg ha-1), specific death rates (yr-1), assimilation efficiencies, and growth efficiencies for all compartments. 

```{r model_data}
# Get food web data on the compartments
foodweb_data <- list(
  # Compartment names
  compartment = c(
    "Detritus", 
    "Roots", 
    "Fungi",
    "Bacteria", 
    "Phytophagous_nematodes", 
    "Collembola", 
    "Cryptostigmatic_mites",
    "Noncryptostigmatic_mites",
    "Fungivorous_nematodes",
    "Enchytraeids",
    "Bacteriophagous_nematodes",
    "Flagellates",
    "Bacteriophagous_mites",
    "Amoebae",
    "Predatory_nematodes",
    "Nematophagous_mites",
    "Predatory_collembola",
    "Predatory_mites"
  ),
  # Biomasses(kg ha-1)
  BM = c(
    2500,
    300,
    2.13,
    227.5,
    0.19,
    0.47,
    0.01,
    0.02,
    0.08,
    0.43,
    0.30,
    0.53,
    0.001,
    11.53,
    0.06,
    0.004,
    0.03,
    0.0635
  ),
  MR = c(
    NA,
    1.00,
    1.20,
    1.20,
    1.08,
    1.84,
    1.20,
    1.84,
    1.92,
    5.00,
    2.68,
    6.00,
    1.84,
    6.00,
    3.00,
    1.84,
    1.84,
    1.84
  ),
  AE = c(
    NA,
    NA,
    1.00,
    1.00,
    0.25,
    0.50,
    0.50,
    0.50,
    0.38,
    0.25,
    0.60,
    0.95,
    0.50,
    0.95,
    0.50,
    0.90,
    0.50,
    0.60
  ),
  GE = c(
    NA,
    NA,
    0.30,
    0.30,
    0.37,
    0.35,
    0.35,
    0.35,
    0.37,
    0.40,
    0.37,
    0.40,
    0.35,
    0.40,
    0.37,
    0.35,
    0.35,
    0.35
  )
)
names(foodweb_data$BM) <- foodweb_data$compartment
names(foodweb_data$MR) <- foodweb_data$compartment
names(foodweb_data$AE) <- foodweb_data$compartment
names(foodweb_data$GE) <- foodweb_data$compartment

FM <- matrix(
  0,
  nrow = length(foodweb_data$compartment), 
  ncol = length(foodweb_data$compartment),
  byrow = T
)
if(T){
  FM[1,3] <- 40.8
  FM[1,4] <- 1606
  FM[2,5] <- 7.44
  FM[3,6] <- 6.65
  FM[3,7] <- 0.08
  FM[3,8] <- 0.34
  FM[3,9] <- 2.51
  FM[3,10] <- 0.09
  FM[1,10] <- 11.1
  FM[4,10] <- 10.1
  FM[4,11] <- 6.89
  FM[4,12] <- 9.46
  FM[4,13] <- 0.01
  FM[4,14] <- 182
  FM[11,15] <- 0.42
  FM[4,15] <- 0.33
  FM[12,15] <- 0.008
  FM[12,14] <- 0.42
  FM[14,15] <- 0.17
  FM[5,18] <- 0.06
  FM[5,17] <- 0.13
  FM[5,16] <- 0.01
  FM[5,15] <- 0.28
  FM[6,18] <- 0.31
  FM[7,18] <- 0.005
  FM[8,18] <- 0.015
  FM[9,18] <- 0.03
  FM[9,17] <- 0.05
  FM[9,16] <- 0.004
  FM[9,15] <- 0.11
  FM[13,18] <- 0.003
  FM[11,18] <- 0.10
  FM[11,17] <- 0.20
  FM[11,16] <- 0.014
  FM[15,18] <- 0.02
  FM[15,17] <- 0.04
  FM[15,16] <- 0.003
  FM[16,18] <- 0.002
  FM[17,18] <- 0.02
}

rownames(FM) <- foodweb_data$compartment
colnames(FM) <- foodweb_data$compartment
```

Now we use this data to calculate interaction strength values to get a Jacobian matrix. The authors state that intragroup interferences i.e. the values for the diagonal of the Jacobian matrix, could not be established empirically. Therefore, the diagonal is set to zero for now (default). In the original paper the interaction strengths related to the detritus compartment were not calculated with a function specific for detritus. Therefore, the results from the paper can be duplicated by NOT defining  detritus as a dead compartment.

```{r}
model <- list(
  type = "EF",
  FM = FM,
  BM = foodweb_data$BM,
  AE = foodweb_data$AE,
  GE = foodweb_data$GE
)
JM <- getJacobian(model)
```

The stability of the food web can now be found by finding the maximum real part of the eigenvalues. Remember our Jacobian matrix has an all-zero diagonal.
```{r}
getStability(JM)
```

It is also possible to find stability as the scalar of the natural mortality rates needed to produce a stable matrix (the method used in the original paper).
```{r eval = FALSE}
getStability(JM, method = "scalar", 
             mortalities = foodweb_data$MR, dead = "Detritus")
```

Both methods are valid, altough it is clear that the actual values differ. Therefore, it is important to know what stability method has been used in order to interpret the results correctly.

It is also possible to calculate values for the diagonal instead of setting them to zero.
```{r eval = FALSE}
JM <- getJacobian(
  FM = FM,
  BM = foodweb_data$BM,
  AE = foodweb_data$AE,
  GE = foodweb_data$GE,
  diagonal = "model",
  dead = list(names = "Detritus"),
  MR = foodweb_data$MR
)

getStability(JM)
```


